/*
    Appellation: interface <module>
    Contrib: FL03 <jo3mccain@icloud.com>
    Description: ... summary ...
*/
use futures::future;
use scsys::{components::networking::Server, prelude::BoxResult};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use tarpc::server::Channel;
use tokio::net::TcpListener;


#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct BaseServer;

/* 
    Implement the sample service on the base server for the rpc backend
    Note: 
        Each defined rpc generates two items within the trait; namely, a function 
        directly servicing the RPC and an associated type representing the future output
        of the function provided.
*/
impl samples::World for BaseServer {
    type HelloFut = future::Ready<String>;

    fn hello(self, _: tarpc::context::Context, name: String) -> Self::HelloFut {
        let msg = format!("Hello, {name}!");
        future::ready(msg)
    }
}

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct RPCBackend {
    pub server: Server
}

impl RPCBackend {
    pub fn new(server: Server) -> Self {
        Self { server }
    }
    pub fn address(&self) -> SocketAddr {
        self.server.clone().address().into()
    }
    pub async fn client(&mut self) -> BoxResult<&Self> {
        Ok(self)
    }
    pub async fn listener(&self) -> BoxResult<TcpListener> {
        tracing::info!("Listening at {}", self.server.clone().address());
        let listener = TcpListener::bind(self.address()).await?;
        Ok(listener)
    }
    pub async fn spawn(&mut self) -> BoxResult {
        tracing::info!("Spawning the rpc server...");
        loop {
            let (_, _) = self.listener().await?.accept().await?;
    
            tokio::spawn(async move {
                // Process each socket concurrently.
                samples::world_client().await.expect("Invalid response");
            });
        }
    }
    pub async fn run(&mut self) -> BoxResult<&Self> {
        self.spawn().await?;
        Ok(self)
    }
}


pub(crate) mod samples {
    use crate::contexts::Context;
    use clap::Parser;
    use futures::future::{self, Ready};
    use scsys::prelude::BoxResult;
    use std::{net::SocketAddr, time::Duration};
    use tarpc::{client, context, tokio_serde::formats::Json, server::{BaseChannel, Channel}};
    use tokio::time::sleep;
    use tracing::Instrument;

    /// This is the service definition. It looks a lot like a trait definition.
    /// It defines one RPC, hello, which takes one arg, name, and returns a String.
    #[tarpc::service]
    pub trait World {
        /// Returns a greeting for name.
        async fn hello(name: String) -> String;
    }

    #[derive(Clone)]
    pub struct WorldServer;

    impl World for WorldServer {
        // Each defined rpc generates two items in the trait, a fn that serves the RPC, and
        // an associated type representing the future output by the fn.

        type HelloFut = Ready<String>;

        fn hello(self, _: tarpc::context::Context, name: String) -> Self::HelloFut {
            future::ready(format!("Hello, {name}!"))
        }
    }


    #[derive(Parser)]
    struct Flags {
        /// Sets the server address to connect to.
        #[clap(long)]
        server_addr: SocketAddr,
        /// Sets the name to say hello to.
        #[clap(long)]
        name: String,
    }

    pub async fn world_client() -> BoxResult {
        let (client_transport, server_transport) = tarpc::transport::channel::unbounded();

        let server = BaseChannel::with_defaults(server_transport);
        tokio::spawn(server.execute(WorldServer.serve()));

        // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
        // that takes a config and any Transport as input.
        let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();

        // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
        // args as defined, with the addition of a Context, which is always the first arg. The Context
        // specifies a deadline and trace information which can be helpful in debugging requests.
        let ts = scsys::prelude::Timestamp::default();
        let hello = client.hello(context::current(), serde_json::to_string(&ts).unwrap()).await?;

        println!("{hello}");
        Ok(())
    }

    pub async fn sample_client(ctx: Context) -> BoxResult {
        let address = ctx.settings.server.address();
        let name = "".to_string();

        
        let transport = tarpc::serde_transport::tcp::connect(address, Json::default);

        let client = WorldClient::new(client::Config::default(), transport.await?).spawn();

        let hello = async move {
            tokio::select! {
                hello1 = client.hello(context::current(), format!("{}1", name)) => { hello1 }
                hello2 = client.hello(context::current(), format!("{}2", name)) => { hello2 }
            }
        }
        .instrument(tracing::info_span!("Two Hellos"))
        .await;

        tracing::info!("{:?}", hello);

        sleep(Duration::from_micros(1)).await;
        opentelemetry::global::shutdown_tracer_provider();

        Ok(())
    }
}